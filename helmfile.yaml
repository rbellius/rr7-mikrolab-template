# helmfiles:
# - # Path to the helmfile state file being processed BEFORE releases in this state file
#   path: helmfile.yaml
#   selectors:
#     - group=cert-manager
# # - path: helmfile.yaml
# #   selectors:
# #     - facetsDns=duckdns


repositories:

    - name: rbel-charts
      url: https://raw.githubusercontent.com/rbellius/charts/main
      
    - name: argo
      url: https://argoproj.github.io/argo-helm



releases:
  - name: kro
    namespace: kro
    createNamespace: true
    chart: oci://ghcr.io/kro-run/kro/kro
    version: 0.4.0
    wait: true
    suppressDiff: true
    # installed: true
    labels:
      group: core
      layer: platform
      stage: init
      step: init
  
    values:
      - crds:
          enabled: true
          keep: false
    hooks:
    - events: ["postsync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          echo "Waiting for ResourceGraphDefinitions CRD to be Ready..."

    - events: ["postsync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          kubectl --kubeconfig /mikrolab/kubeconfig.yaml wait --for=condition=Established --timeout=30s crds resourcegraphdefinitions.kro.run
          echo "ResourceGraphDefinitions CRD is Ready!"
          sleep 5

  
  - name: argocd
    namespace: argocd
    createNamespace: true
    chart: argo/argo-cd
    version: 8.3.0
    wait: true
    suppressDiff: true
    labels:
      group: core
      layer: platform
      stage: init
      step: init
    values:
        - crds:
            create: true
            keep: false
        
      #   configs:
      #     cm:
      #       timeout.reconciliation: 15s
      #     params:
      #       server.insecure: true
      #     server:
      #       ingress:
      #         enabled: false
      #   dex:
      #     enabled: false
      #       crds:
      #       create: true
      #       keep: false

          dex:
            enabled: false


          configs:
            params:
              server.insecure: true


            cm:
              timeout.reconciliation: 15s
              application.resourceTrackingMethod: "annotation+label"
              applicationsetcontroller.enable.new.git.file.globbing: "true"
              resource.customizations.health.argoproj.io_Application: |
                hs = {}
                hs.status = "Progressing"
                hs.message = ""
                if obj.status ~= nil then
                  if obj.status.health ~= nil then
                    hs.status = obj.status.health.status
                    if obj.status.health.message ~= nil then
                      hs.message = obj.status.health.message
                    end
                  end
                end
                return hs
              resource.customizations.health.argoproj.io_ApplicationSet: |
                local hs = {}

                if obj.status ~= nil then
                  if obj.status.conditions ~= nil then
                    for i, condition in pairs(obj.status.conditions) do
                      if condition.type == "ErrorOccurred" and condition.status == "True" then
                        hs.status = "Degraded"
                        hs.message = condition.message
                        return hs
                      end
                    end
                    for i, condition in pairs(obj.status.conditions) do
                      if condition.type == "ResourcesUpToDate" and condition.status == "False" then
                        hs.status = "Degraded"
                        hs.message = condition.message
                        return hs
                      end
                    end
                    for i, condition in pairs(obj.status.conditions) do
                      if condition.type == "RolloutProgressing" and condition.status == "True" then
                        hs.status = "Progressing"
                        hs.message = condition.message
                        return hs
                      end
                    end
                    for i, condition in pairs(obj.status.conditions) do
                      if condition.type == "ResourcesUpToDate" and condition.status == "True" then
                        hs.status = "Healthy"
                        hs.message = condition.message
                        return hs
                      end
                    end
                  end
                end

                hs.status = "Progressing"
                hs.message = "Waiting for the status to be reported"
                return hs
              resource.customizations.health.apiextentions.k8s.io_CustomResourceDefinition: |
                  local hs = {}

                  -- Check if CRD is terminating
                  if obj.metadata.deletionTimestamp ~= nil then
                      hs.status = "Progressing"
                      hs.message = "CRD is terminating"
                      return hs
                  end

                  if obj.status.conditions == nil then
                      hs.status = "Progressing"
                      hs.message = "Status conditions not found"
                      return hs
                  end

                  if #obj.status.conditions == 0 then
                      hs.status = "Progressing"
                      hs.message = "Status conditions not found"
                      return hs
                  end

                  local isEstablished
                  local conditionMsg = ""

                  for _, condition in pairs(obj.status.conditions) do

                      -- Check if CRD is terminating
                      if condition.type == "Terminating" and condition.status == "True" then
                          hs.status = "Progressing"
                          hs.message = "CRD is terminating: " .. condition.message
                          return hs
                      end

                      -- Check if K8s has accepted names for this CRD
                      if condition.type == "NamesAccepted" and condition.status == "False" then
                          hs.status = "Degraded"
                          hs.message = "CRD names have not been accepted: " .. condition.message
                          return hs
                      end

                      -- Checking if CRD has violations
                      if condition.type == "NonStructuralSchema" and condition.status == "True" then
                          hs.status = "Degraded"
                          hs.message = "Schema violations found: " .. condition.message
                          return hs
                      end

                      -- Checking if CRD is established
                      if condition.type == "Established" and condition.status == "True" then
                          isEstablished = true
                          conditionMsg = condition.message
                      end
                  end

                  if not isEstablished then
                      hs.status = "Degraded"
                      hs.message = "CRD is not established"
                      return hs
                  end

                  hs.status = "Healthy"
                  hs.message = "CRD is healthy"
                  return hs
              resource.customizations.health.cert-manager.io_Certificate: |
                hs = {}
                if obj.status ~= nil then
                  if obj.status.conditions ~= nil then
                    for i, condition in ipairs(obj.status.conditions) do
                      if condition.type == "Ready" and condition.status == "False" then
                        hs.status = "Degraded"
                        hs.message = condition.message
                        return hs
                      end
                      if condition.type == "Ready" and condition.status == "True" then
                        hs.status = "Healthy"
                        hs.message = condition.message
                        return hs
                      end
                    end
                  end
                end

                hs.status = "Progressing"
                hs.message = "Waiting for certificate"
                return hs

    hooks:
    - events: ["postsync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          echo "Waiting for ArgoCD Applications and ApplicationSet CRDs to be Ready..."
          # sleep 10;

    - events: ["postsync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          kubectl --kubeconfig /mikrolab/kubeconfig.yaml wait --for=condition=Established --timeout=-1s crds application.argoproj.io applicationset.argoproj.io
          echo "Application CRD is Ready!"
    

  - name: argofile-rgd-loader-application
    namespace: argocd
    createNamespace: true
    # chart: rbel-charts/argofile-applicationset-rgd
    chart: ./resources/applications/argofile
    version: 0.1.0
    wait: true
    suppressDiff: true
    disableValidationOnInstall: true
    disableValidation: true
    labels:
      group: argofile
      layer: platform
      stage: init
      step: argofile
    needs:
      - argocd/argocd
      - kro/kro

    hooks:

    - events: ["postsync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          echo "Waiting for all ArgoCD Applications to be Healthy..."
    - events: ["postsync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          sleep 10;
          kubectl --kubeconfig /mikrolab/kubeconfig.yaml wait --for=jsonpath='{.status.health.status}'=Healthy application --all -A --timeout=-1s
          # kubectl --kubeconfig /mikrolab/kubeconfig.yaml wait --for=condition=Established --timeout=-1s crds applicationsets.argoproj.io resourcegraphdefinitions.kro.run
    - events: ["postsync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          echo "Waiting for all ResourceGraphDefinitions to be Ready..."
    - events: ["postsync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          # sleep 10;
          # kubectl --kubeconfig /mikrolab/kubeconfig.yaml wait --for=condition=Established --timeout=120s rgd/certmanagerbundles.kro.run
          kubectl --kubeconfig /mikrolab/kubeconfig.yaml wait --for=condition=Ready --timeout=-1s rgd -A --all
          echo "All ResourceGraphDefinitions are Ready!"
          pwd


  - name: platform-argofile
    namespace: platform
    createNamespace: true
    chart: ./resources/instances/argofiles
    version: 0.1.0
    wait: true
    suppressDiff: true
    disableValidationOnInstall: true
    disableValidation: true
    labels:
      group: argofile
      layer: platform
      stage: config
      step: argofile
    needs:
      - kro/kro
      - argocd/argocd
      - argocd/argofile-rgd-loader-application
      
  - name: mikrolab-config
    namespace: mikrolab
    createNamespace: true
    chart: ./resources/instances/mikrolab
    version: 0.1.0
    wait: true
    suppressDiff: true
    disableValidationOnInstall: true
    disableValidation: true
    labels:
      group: mikrolab
      layer: platform
      stage: config
      step: mikrolab
    needs:
      - kro/kro
      - argocd/argocd
      - argocd/argofile-rgd-loader-application
      - platform/platform-argofile
      
    hooks:
    - events: ["presync"]
      showlogs: true
      command: echo
      args: 
        # Consider renaming the current MikroLab CR to mikrolab-config to avoid confusion with the release name
        - "Waiting for Mikrolab and WebApplication CRDs to be Ready..."

    - events: ["presync"]
      showlogs: true
      command: sh
      args:
        - -c
        - |
          sleep 10;
          kubectl --kubeconfig mikrolab/kubeconfig.yaml wait --for=condition=Established --timeout=120s crds mikrolabs.kro.run  webapplications.kro.run
          echo "Mikrolab and WebApplication CRDs are Ready!"
 


  # - name: local-apps-instances
  #   namespace: mikrolab
  #   createNamespace: true
  #   chart: ./resources/instances/mikrolab
  #   version: 0.1.0
  #   wait: true
  #   suppressDiff: true
  #   disableValidationOnInstall: true
  #   disableValidation: true
  #   labels:
  #     group: mikrolab
  #     layer: platform
  #     stage: config
  #     step: mikrolab
  #   needs:
  #     - kro/kro
  #     - argocd/argocd
  #     - argocd/argofile-rgd-loader-application
  #     - platform/platform-argofile
      